#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <ctype.h>
#include <sqlca.h>
#include <sqlcpr.h>
#include "sql.h"

void sql_error(char *msg){
    EXEC SQL WHENEVER SQLERROR CONTINUE;

    wscrl(console_win, 1);
    wmove(console_win, CONSOLE_HEIGHT - 2, 1);
    if (has_colors()) { wattron(console_win, COLOR_PAIR(1) | A_BOLD); }
    wprintw(console_win, " [치명적 오류] C 호출 중 Oracle 오류 발생: %s", msg); 
    if (has_colors()) { wattroff(console_win, COLOR_PAIR(1) | A_BOLD); }

    if (sqlca.sqlerrm.sqlerrml > 0) {
        wscrl(console_win, 1);
        wmove(console_win, CONSOLE_HEIGHT - 1, 1);
        if (has_colors()) { wattron(console_win, COLOR_PAIR(1)); }
        wprintw(console_win, " [세부 정보] (%.*s)", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc); 
        if (has_colors()) { wattroff(console_win, COLOR_PAIR(1)); }
    }
    wrefresh(console_win);

    EXEC SQL ROLLBACK RELEASE;
    
    exit(1);
}

EXEC SQL BEGIN DECLARE SECTION;
    VARCHAR barcode_hv[21];
    VARCHAR dist_id_hv[4];
    VARCHAR prod_id_hv[5];
    VARCHAR prod_name_hv[101];
    VARCHAR cate_id_hv[11];

    int inb_qty_num_hv;
    float inb_cost_num_hv;

    VARCHAR inb_id_hv[16];
    VARCHAR inv_id_hv[16];

    int count_hv;
    char exist_prod_id_hv[1];

    VARCHAR old_prod_id_hv[5];
    VARCHAR old_dist_id_hv[4];
    VARCHAR old_cate_id_hv[11];
    VARCHAR old_inb_date_hv[9];
    int old_inb_qty_num_hv;
    float old_inb_cost_num_hv;

    VARCHAR final_inb_date_hv[9];

    int current_qty_hv;
    float sell_price_hv;
    int requested_qty_hv;

    char db_user[] = "SYSTEM";
    char db_pass[] = "epdlxjqpdltmdmddyd";
    char db_connect_string[] = "XE_DOCKER";

    char sysdate_str[20];
EXEC SQL END DECLARE SECTION;

int inbound_insert(wchar_t* input_buffer_w) {

    char input_buffer_c[512] = {0};
    char *token_arr[5];
    char temp_input[512];
    char *current_token;
    char *saveptr;
    int field_count = 0;
    int return_status = 0;

    EXEC SQL WHENEVER SQLERROR DO sql_error("C 호출 중 Oracle 오류 발생"); 

    wscrl(console_win, 1);
    wmove(console_win, CONSOLE_HEIGHT - 2, 1);
    if (has_colors()) {wattron(console_win, COLOR_PAIR(2)); }
    wprintw(console_win, " [정보] DB 연결 시도 중: %s", db_connect_string);
    if (has_colors()) {wattroff(console_win, COLOR_PAIR(2)); }

    EXEC SQL CONNECT :db_user IDENTIFIED BY :db_pass USING :db_connect_string;

    wscrl(console_win, 1);
    wmove(console_win, CONSOLE_HEIGHT - 2, 1);
    if (has_colors()) {wattron(console_win, COLOR_PAIR(3)); }
    wprintw(console_win, " [정보] DB 연결 성공.");
    if (has_colors()) {wattroff(console_win, COLOR_PAIR(3)); }
    wrefresh(console_win);

    if (wcstombs(input_buffer_c, input_buffer_w, sizeof(input_buffer_c)) == (size_t)-1) {
        wscrl(console_win, 1);
        wmove(console_win, CONSOLE_HEIGHT - 2, 1);
        if (has_colors()) {wattron(console_win, COLOR_PAIR(4) | A_BOLD | A_DIM); }
        wprintw(console_win, " [로그] [입고 관리] 입력 오류: 와이드 문자열 변환 실패.");
        if (has_colors()) {wattroff(console_win, COLOR_PAIR(4) | A_BOLD | A_DIM); }
        return_status = 0;
        goto cleanup;
    }

    strcpy(temp_input, input_buffer_c);

    current_token = strtok_r(temp_input, ",", &saveptr);
    while (current_token != NULL && field_count < 5) {
        token_arr[field_count] = trim_whitespace(current_token);
        field_count++;
        current_token = strtok_r(NULL, ",", &saveptr);
    }

    if (field_count != 5) {
        wscrl(console_win, 1);
        wmove(console_win, CONSOLE_HEIGHT - 2, 1);
        if (has_colors()) {wattron(console_win, COLOR_PAIR(4) | A_BOLD | A_DIM); }
        wprintw(console_win, " [로그] [입고 관리] 입력 오류: 필드 개수 불일치 (%d개).", field_count);
        if (has_colors()) {wattroff(console_win, COLOR_PAIR(4) | A_BOLD | A_DIM); }
        return_status = 0;
        goto cleanup;
    }

    if (strlen(token_arr[0]) != 7 || !is_numeric(token_arr[0])) {
        wscrl(console_win, 1);
        wmove(console_win, CONSOLE_HEIGHT - 2, 1);
        if (has_colors()) {wattron(console_win, COLOR_PAIR(4) | A_BOLD | A_DIM); }
        wprintw(console_win, " [로그] [입고 관리] 입력 오류: 바코드는 7자리 숫자여야 합니다.");
        if (has_colors()) {wattroff(console_win, COLOR_PAIR(4) | A_BOLD | A_DIM); }
        return_status = 0;
        goto cleanup;
    }

    if (!is_numeric(token_arr[1]) || !is_numeric(token_arr[2])) {
        wscrl(console_win, 1);
        wmove(console_win, CONSOLE_HEIGHT - 2, 1);
        if (has_colors()) {wattron(console_win, COLOR_PAIR(4) | A_BOLD | A_DIM); }
        wprintw(console_win, " [로그] [입고 관리] 입력 오류: 수량 또는 단가가 숫자가 아닙니다.");
        if (has_colors()) {wattroff(console_win, COLOR_PAIR(4) | A_BOLD | A_DIM); }
        return_status = 0;
        goto cleanup;
    }

    strcpy((char*)barcode_hv.arr, token_arr[0]);
    barcode_hv.len = strlen(token_arr[0]);

    strncpy((char*)dist_id_hv.arr, token_arr[0], 3);
    dist_id_hv.arr[3] = '\0';
    dist_id_hv.len = 3;

    strncpy((char*)prod_id_hv.arr, token_arr[0] + 3, 4);
    prod_id_hv.arr[4] = '\0';
    prod_id_hv.len = 4;

    strcpy((char*)cate_id_hv.arr, token_arr[3]);
    cate_id_hv.len = strlen(token_arr[3]);

    strcpy((char*)prod_name_hv.arr, token_arr[4]);
    prod_name_hv.len = strlen(token_arr[4]);

    inb_qty_num_hv = atoi(token_arr[1]);
    inb_cost_num_hv = atof(token_arr[2]);

    count_hv = 0;
    EXEC SQL SELECT COUNT(*) INTO :count_hv FROM SYSTEM.DISTRIBUTOR WHERE DIST_ID = :dist_id_hv;
    if (count_hv == 0) {
        wscrl(console_win, 1);
        wmove(console_win, CONSOLE_HEIGHT - 2, 1);
        if (has_colors()) {wattron(console_win, COLOR_PAIR(4) | A_BOLD | A_DIM); }
        wprintw(console_win, " [로그] [입고 관리] 유통업체 ID (%.*s)가 존재하지 않습니다.", dist_id_hv.len, dist_id_hv.arr);
        if (has_colors()) {wattroff(console_win, COLOR_PAIR(4) | A_BOLD | A_DIM); }
        return_status = 0;
        goto cleanup;
    }

    count_hv = 0;
    EXEC SQL SELECT COUNT(*) INTO :count_hv FROM SYSTEM.CATEGORY WHERE CATE_ID = :cate_id_hv;
    if (count_hv == 0) {
        wscrl(console_win, 1);
        wmove(console_win, CONSOLE_HEIGHT - 2, 1);
        if (has_colors()) {wattron(console_win, COLOR_PAIR(4) | A_BOLD | A_DIM); }
        wprintw(console_win, " [로그] [입고 관리] 카테고리 ID (%.*s)가 존재하지 않습니다.", cate_id_hv.len, cate_id_hv.arr);
        if (has_colors()) {wattroff(console_win, COLOR_PAIR(4) | A_BOLD | A_DIM); }
        return_status = 0;
        goto cleanup;
    }

    count_hv = 0;
    EXEC SQL SELECT COUNT(PROD_ID) INTO :count_hv FROM SYSTEM.PRODUCT WHERE PROD_ID = :prod_id_hv;

    if (count_hv == 0) {
        EXEC SQL INSERT INTO SYSTEM.PRODUCT (PROD_ID, CATE_ID, PROD_NAME, BARCODE, SELL_PRICE)
        VALUES (:prod_id_hv, :cate_id_hv, :prod_name_hv, :barcode_hv, :inb_cost_num_hv);

        wscrl(console_win, 1);
        wmove(console_win, CONSOLE_HEIGHT - 2, 1);
        if (has_colors()) {wattron(console_win, COLOR_PAIR(2)); }
        wprintw(console_win, " [정보] 신규 상품 (%.*s)이 PRODUCT 테이블에 등록되었습니다.", prod_id_hv.len, prod_id_hv.arr);
        if (has_colors()) {wattroff(console_win, COLOR_PAIR(2)); }
    }

    long next_inb_val;
    EXEC SQL SELECT SYSTEM.INB_ID_SEQ.NEXTVAL INTO :next_inb_val FROM DUAL;

    sprintf((char*)inb_id_hv.arr, "%015ld", next_inb_val);
    inb_id_hv.len = strlen((char*)inb_id_hv.arr);

    EXEC SQL INSERT INTO SYSTEM.INBOUND (INB_ID, PROD_ID, DIST_ID, CATE_ID, INB_DATE, INB_QTY, INB_COST)
    VALUES (:inb_id_hv, :prod_id_hv, :dist_id_hv, :cate_id_hv, SYSDATE, :inb_qty_num_hv, :inb_cost_num_hv);

    wscrl(console_win, 1);
    wmove(console_win, CONSOLE_HEIGHT - 2, 1);
    if (has_colors()) {wattron(console_win, COLOR_PAIR(2)); }
    wprintw(console_win, " [정보] 입고 레코드 (%.*s)가 INBOUND 테이블에 삽입되었습니다.", inb_id_hv.len, inb_id_hv.arr);
    if (has_colors()) {wattroff(console_win, COLOR_PAIR(2)); }

    EXEC SQL UPDATE SYSTEM.INVENTORY
        SET CURRENT_QTY = CURRENT_QTY + :inb_qty_num_hv,
            LAST_INB_DATE = SYSDATE
        WHERE PROD_ID = :prod_id_hv;

    if (sqlca.sqlerrd[2] == 0) {
        long next_inv_val;
        EXEC SQL SELECT SYSTEM.INV_ID_SEQ.NEXTVAL INTO :next_inv_val FROM DUAL;

        sprintf((char*)inv_id_hv.arr, "%015ld", next_inv_val);
        inv_id_hv.len = strlen((char*)inv_id_hv.arr);

        EXEC SQL INSERT INTO SYSTEM.INVENTORY (INV_ID, PROD_ID, CURRENT_QTY, LAST_INB_DATE)
        VALUES (:inv_id_hv, :prod_id_hv, :inb_qty_num_hv, SYSDATE);

        wscrl(console_win, 1);
        wmove(console_win, CONSOLE_HEIGHT - 2, 1);
        if (has_colors()) {wattron(console_win, COLOR_PAIR(2)); }
        wprintw(console_win, " [정보] 신규 재고 레코드 (%.*s)가 INVENTORY 테이블에 삽입되었습니다.", inv_id_hv.len, inv_id_hv.arr);
        if (has_colors()) {wattroff(console_win, COLOR_PAIR(2)); }
    } else {
        wscrl(console_win, 1);
        wmove(console_win, CONSOLE_HEIGHT - 2, 1);
        if (has_colors()) {wattron(console_win, COLOR_PAIR(2)); }
        wprintw(console_win, " [정보] 상품 (%.*s)의 기존 재고가 갱신되었습니다.", prod_id_hv.len, prod_id_hv.arr);
        if (has_colors()) {wattroff(console_win, COLOR_PAIR(2)); }
    }

    return_status = 1;

cleanup:

    if (return_status == 1) {
        EXEC SQL COMMIT WORK RELEASE;
        wscrl(console_win, 1);
        wmove(console_win, CONSOLE_HEIGHT - 2, 1);
        if (has_colors()) {wattron(console_win, COLOR_PAIR(3) | A_BOLD); }
        wprintw(console_win, " [성공] 트랜잭션 커밋 및 연결 종료. 입고 등록 완료.");
        if (has_colors()) {wattroff(console_win, COLOR_PAIR(3) | A_BOLD); }
    } else {
        EXEC SQL ROLLBACK RELEASE;
        wscrl(console_win, 1);
        wmove(console_win, CONSOLE_HEIGHT - 1, 1);
        if (has_colors()) {wattron(console_win, COLOR_PAIR(4) | A_BOLD); }
        wprintw(console_win, " [오류] 트랜잭션 롤백 및 연결 종료. 입고 등록 실패.");
        if (has_colors()) {wattroff(console_win, COLOR_PAIR(4) | A_BOLD); }
    }
    
    wrefresh(console_win);

    return return_status;
}

// delete
int inbound_delete(wchar_t* input_buffer_w) {

    char input_buffer_c[512] = {0};
    char *token;
    int return_status = 0;
    int delete_count = 0;

    EXEC SQL WHENEVER SQLERROR DO sql_error("C 호출 중 Oracle 오류 발생 (삭제)");

    wscrl(console_win, 1);
    wmove(console_win, CONSOLE_HEIGHT - 2, 1);
    if (has_colors()) {wattron(console_win, COLOR_PAIR(2)); }
    wprintw(console_win, " [정보] DB 연결 시도 중: %s", db_connect_string);
    if (has_colors()) {wattroff(console_win, COLOR_PAIR(2)); }

    EXEC SQL CONNECT :db_user IDENTIFIED BY :db_pass USING :db_connect_string;

    wscrl(console_win, 1);
    wmove(console_win, CONSOLE_HEIGHT - 2, 1);
    if (has_colors()) {wattron(console_win, COLOR_PAIR(3)); }
    wprintw(console_win, " [정보] DB 연결 성공."); 
    if (has_colors()) {wattroff(console_win, COLOR_PAIR(3)); }
    wrefresh(console_win);

    if (wcstombs(input_buffer_c, input_buffer_w, sizeof(input_buffer_c)) == (size_t)-1) {
        wscrl(console_win, 1);
        wmove(console_win, CONSOLE_HEIGHT - 2, 1);
        if (has_colors()) {wattron(console_win, COLOR_PAIR(4) | A_BOLD | A_DIM); }
        wprintw(console_win, " [로그] [입고 삭제] 입력 오류: 와이드 문자열 변환 실패.");
        if (has_colors()) {wattroff(console_win, COLOR_PAIR(4) | A_BOLD | A_DIM); }
        return_status = 0;
        goto cleanup;
    }

    token = trim_whitespace(input_buffer_c);
    if (strlen(token) == 0) {
        wscrl(console_win, 1);
        wmove(console_win, CONSOLE_HEIGHT - 2, 1);
        if (has_colors()) {wattron(console_win, COLOR_PAIR(4) | A_BOLD | A_DIM); }
        wprintw(console_win, " [로그] [입고 삭제] 입력 오류: 삭제할 입고 ID를 입력하세요.");
        if (has_colors()) {wattroff(console_win, COLOR_PAIR(4) | A_BOLD | A_DIM); }
        return_status = 0;
        goto cleanup;
    }

    strcpy((char*)inb_id_hv.arr, token);
    inb_id_hv.len = strlen(token);

    wscrl(console_win, 1);
    wmove(console_win, CONSOLE_HEIGHT - 2, 1);
    if (has_colors()) {wattron(console_win, COLOR_PAIR(2)); }
    wprintw(console_win, " [정보] 입고 ID (%.*s) 레코드 삭제 명령 실행...", inb_id_hv.len, inb_id_hv.arr);
    if (has_colors()) {wattroff(console_win, COLOR_PAIR(2)); }

    EXEC SQL DELETE FROM SYSTEM.INBOUND
             WHERE INB_ID = :inb_id_hv;

    delete_count = sqlca.sqlerrd[2];

    if (delete_count == 0) {
        wscrl(console_win, 1);
        wmove(console_win, CONSOLE_HEIGHT - 2, 1);
        if (has_colors()) {wattron(console_win, COLOR_PAIR(4) | A_BOLD | A_DIM); }
        wprintw(console_win, " [로그] [입고 삭제] 오류: 입고 ID (%.*s)를 찾을 수 없습니다.",
                 inb_id_hv.len, inb_id_hv.arr);
        if (has_colors()) {wattroff(console_win, COLOR_PAIR(4) | A_BOLD | A_DIM); }
        return_status = 0;
    } else {
        wscrl(console_win, 1);
        wmove(console_win, CONSOLE_HEIGHT - 2, 1);
        if (has_colors()) {wattron(console_win, COLOR_PAIR(2)); }
        wprintw(console_win, " [정보] 입고 레코드 %d건이 성공적으로 삭제되었습니다.", delete_count);
        if (has_colors()) {wattroff(console_win, COLOR_PAIR(2)); }
        return_status = 1;
    }

    goto cleanup;

cleanup:

    if (return_status == 1) {
        EXEC SQL COMMIT WORK RELEASE;
        wscrl(console_win, 1);
        wmove(console_win, CONSOLE_HEIGHT - 2, 1);
        if (has_colors()) {wattron(console_win, COLOR_PAIR(3) | A_BOLD); }
        wprintw(console_win, " [성공] 트랜잭션 커밋 및 연결 종료. 입고 삭제 완료.");
        if (has_colors()) {wattroff(console_win, COLOR_PAIR(3) | A_BOLD); }
    } else {
        EXEC SQL ROLLBACK RELEASE;
        wscrl(console_win, 1);
        wmove(console_win, CONSOLE_HEIGHT - 1, 1);
        if (has_colors()) {wattron(console_win, COLOR_PAIR(4) | A_BOLD); }
        wprintw(console_win, " [오류] 트랜잭션 롤백 및 연결 종료. 입고 삭제 실패.");
        if (has_colors()) {wattroff(console_win, COLOR_PAIR(4) | A_BOLD); }
    }
    
    wrefresh(console_win);

    return return_status;
}

// modify
int inbound_modify(wchar_t* input_buffer_w) {

    char input_buffer_c[512] = {0};
    char *token_arr[7];
    char temp_input[512];
    char *current_token;
    char *saveptr;
    int field_count = 0;
    int return_status = 0;

    EXEC SQL WHENEVER SQLERROR DO sql_error("C 호출 중 Oracle 오류 발생 (수정)");

    wscrl(console_win, 1);
    wmove(console_win, CONSOLE_HEIGHT - 2, 1);
    if (has_colors()) {wattron(console_win, COLOR_PAIR(2)); }
    wprintw(console_win, " [정보] DB 연결 시도 중: %s", db_connect_string);
    if (has_colors()) {wattroff(console_win, COLOR_PAIR(2)); }
    wrefresh(console_win);

    EXEC SQL CONNECT :db_user IDENTIFIED BY :db_pass USING :db_connect_string;

    wscrl(console_win, 1);
    wmove(console_win, CONSOLE_HEIGHT - 2, 1);
    if (has_colors()) {wattron(console_win, COLOR_PAIR(3)); }
    wprintw(console_win, " [정보] DB 연결 성공.");
    if (has_colors()) {wattroff(console_win, COLOR_PAIR(3)); }
    wrefresh(console_win);

    if (wcstombs(input_buffer_c, input_buffer_w, sizeof(input_buffer_c)) == (size_t)-1) {
        wscrl(console_win, 1); wmove(console_win, CONSOLE_HEIGHT - 2, 1);
        if (has_colors()) {wattron(console_win, COLOR_PAIR(4) | A_BOLD | A_DIM); }
        wprintw(console_win, " [로그] [입고 수정] 입력 오류: 와이드 문자열 변환 실패.");
        if (has_colors()) {wattroff(console_win, COLOR_PAIR(4) | A_BOLD | A_DIM); }
        return_status = 0; goto cleanup;
    }

    strcpy(temp_input, input_buffer_c);

    current_token = strtok_r(temp_input, ",", &saveptr);
    while (current_token != NULL && field_count < 7) {
        token_arr[field_count] = trim_whitespace(current_token);
        field_count++;
        current_token = strtok_r(NULL, ",", &saveptr);
    }

    if (field_count != 7) {
        wscrl(console_win, 1); wmove(console_win, CONSOLE_HEIGHT - 2, 1);
        if (has_colors()) {wattron(console_win, COLOR_PAIR(4) | A_BOLD | A_DIM); }
        wprintw(console_win, " [로그] [입고 수정] 입력 오류: 필드 개수 불일치 (%d개, 예상 7개).", field_count);
        if (has_colors()) {wattroff(console_win, COLOR_PAIR(4) | A_BOLD | A_DIM); }
        return_status = 0; goto cleanup;
    }

    strcpy((char*)inb_id_hv.arr, token_arr[0]);
    inb_id_hv.len = strlen(token_arr[0]);

    EXEC SQL SELECT PROD_ID, DIST_ID, CATE_ID, TO_CHAR(INB_DATE, 'YYYYMMDD'), INB_QTY, INB_COST
    INTO :old_prod_id_hv, :old_dist_id_hv, :old_cate_id_hv, :old_inb_date_hv, :old_inb_qty_num_hv, :old_inb_cost_num_hv
    FROM SYSTEM.INBOUND
    WHERE INB_ID = :inb_id_hv;

    if (sqlca.sqlcode == 1403) {
        wscrl(console_win, 1); wmove(console_win, CONSOLE_HEIGHT - 2, 1);
        if (has_colors()) {wattron(console_win, COLOR_PAIR(4) | A_BOLD | A_DIM); }
        wprintw(console_win, " [로그] [입고 수정] 오류: 입고 ID (%.*s)를 찾을 수 없습니다.", inb_id_hv.len, inb_id_hv.arr); 
        if (has_colors()) {wattroff(console_win, COLOR_PAIR(4) | A_BOLD | A_DIM); }
        return_status = 0; goto cleanup;
    }

    int is_actually_updated = 0;

    if (strcmp(token_arr[1], "@") != 0) {
        if (strlen(token_arr[1]) > 4) { return_status = 0; goto cleanup; }
        EXEC SQL SELECT COUNT(*) INTO :count_hv FROM SYSTEM.PRODUCT WHERE PROD_ID = :token_arr[1];
        if (count_hv == 0) { wprintw(console_win, " [로그] [입고 수정] 오류: 상품 ID가 DB에 존재하지 않습니다."); return_status = 0; goto cleanup; } 

        strcpy((char*)prod_id_hv.arr, token_arr[1]);
        prod_id_hv.len = strlen(token_arr[1]);
        is_actually_updated = 1;
    } else {
        strcpy((char*)prod_id_hv.arr, (char*)old_prod_id_hv.arr);
        prod_id_hv.len = old_prod_id_hv.len;
    }

    if (strcmp(token_arr[2], "@") != 0) {
        EXEC SQL SELECT COUNT(*) INTO :count_hv FROM SYSTEM.DISTRIBUTOR WHERE DIST_ID = :token_arr[2];
        if (count_hv == 0) { wprintw(console_win, " [로그] [입고 수정] 오류: 유통업체 ID가 DB에 존재하지 않습니다."); return_status = 0; goto cleanup; } 

        strcpy((char*)dist_id_hv.arr, token_arr[2]);
        dist_id_hv.len = strlen(token_arr[2]);
        is_actually_updated = 1;
    } else {
        strcpy((char*)dist_id_hv.arr, (char*)old_dist_id_hv.arr);
        dist_id_hv.len = old_dist_id_hv.len;
    }

    if (strcmp(token_arr[3], "@") != 0) {
        EXEC SQL SELECT COUNT(*) INTO :count_hv FROM SYSTEM.CATEGORY WHERE CATE_ID = :token_arr[3];
        if (count_hv == 0) { wprintw(console_win, " [로그] [입고 수정] 오류: 카테고리 ID가 DB에 존재하지 않습니다."); return_status = 0; goto cleanup; } 

        strcpy((char*)cate_id_hv.arr, token_arr[3]);
        cate_id_hv.len = strlen(token_arr[3]);
        is_actually_updated = 1;
    } else {
        strcpy((char*)cate_id_hv.arr, (char*)old_cate_id_hv.arr);
        cate_id_hv.len = old_cate_id_hv.len;
    }

    if (strcmp(token_arr[4], "@") != 0) {
        strcpy((char*)final_inb_date_hv.arr, token_arr[4]);
        final_inb_date_hv.len = strlen(token_arr[4]);
        is_actually_updated = 1;
    } else {
        strcpy((char*)final_inb_date_hv.arr, (char*)old_inb_date_hv.arr);
        final_inb_date_hv.len = old_inb_date_hv.len;
    }

    if (strcmp(token_arr[5], "@") != 0) {
        if (!is_numeric(token_arr[5])) { wprintw(console_win, " [로그] [입고 수정] 오류: 수량은 숫자여야 합니다."); return_status = 0; goto cleanup; } 
        inb_qty_num_hv = atoi(token_arr[5]);
        is_actually_updated = 1;
    } else {
        inb_qty_num_hv = old_inb_qty_num_hv;
    }

    if (strcmp(token_arr[6], "@") != 0) {
        if (!is_numeric(token_arr[6])) { wprintw(console_win, " [로그] [입고 수정] 오류: 단가는 숫자여야 합니다."); return_status = 0; goto cleanup; } 
        inb_cost_num_hv = atof(token_arr[6]);
        is_actually_updated = 1;
    } else {
        inb_cost_num_hv = old_inb_cost_num_hv;
    }


    if (is_actually_updated) {
        wscrl(console_win, 1); wmove(console_win, CONSOLE_HEIGHT - 2, 1);
        if (has_colors()) {wattron(console_win, COLOR_PAIR(2)); }
        wprintw(console_win, " [정보] 입고 (%.*s) 정보 업데이트 실행 중...", inb_id_hv.len, inb_id_hv.arr); 
        if (has_colors()) {wattroff(console_win, COLOR_PAIR(2)); }

        EXEC SQL UPDATE SYSTEM.INBOUND SET
            PROD_ID = :prod_id_hv,
            DIST_ID = :dist_id_hv,
            CATE_ID = :cate_id_hv,
            INB_DATE = TO_DATE(:final_inb_date_hv, 'YYYYMMDD'),
            INB_QTY = :inb_qty_num_hv,
            INB_COST = :inb_cost_num_hv
        WHERE INB_ID = :inb_id_hv;

        if (sqlca.sqlerrd[2] == 0) {
            wscrl(console_win, 1); wmove(console_win, CONSOLE_HEIGHT - 2, 1);
            if (has_colors()) {wattron(console_win, COLOR_PAIR(4) | A_BOLD | A_DIM); }
            wprintw(console_win, " [로그] [입고 수정] 오류: 입고 ID (%.*s)를 찾을 수 없습니다 (UPDATE 실패).", inb_id_hv.len, inb_id_hv.arr); 
            if (has_colors()) {wattroff(console_win, COLOR_PAIR(4) | A_BOLD | A_DIM); }
            return_status = 0;
        } else {
            wscrl(console_win, 1); wmove(console_win, CONSOLE_HEIGHT - 2, 1);
            if (has_colors()) {wattron(console_win, COLOR_PAIR(3) | A_BOLD); }
            wprintw(console_win, " [성공] 입고 ID (%.*s) 정보가 성공적으로 수정되었습니다.", inb_id_hv.len, inb_id_hv.arr); 
            if (has_colors()) {wattroff(console_win, COLOR_PAIR(3) | A_BOLD); }
            return_status = 1;
        }
    } else {
        wscrl(console_win, 1); wmove(console_win, CONSOLE_HEIGHT - 2, 1);
        if (has_colors()) {wattron(console_win, COLOR_PAIR(4) | A_BOLD | A_DIM); }
        wprintw(console_win, " [로그] [입고 수정] 오류: 수정할 항목이 없습니다 ('@'만 입력됨)."); 
        if (has_colors()) {wattroff(console_win, COLOR_PAIR(4) | A_BOLD | A_DIM); }
        return_status = 0;
    }

cleanup:

    if (return_status == 1) {
        EXEC SQL COMMIT WORK RELEASE;
        wscrl(console_win, 1); wmove(console_win, CONSOLE_HEIGHT - 1, 1);
        if (has_colors()) {wattron(console_win, COLOR_PAIR(3) | A_BOLD); }
        wprintw(console_win, " [성공] 트랜잭션 커밋 및 연결 종료."); 
        if (has_colors()) {wattroff(console_win, COLOR_PAIR(3) | A_BOLD); }
    } else {
        EXEC SQL ROLLBACK RELEASE;
        wscrl(console_win, 1); wmove(console_win, CONSOLE_HEIGHT - 1, 1);
        if (has_colors()) {wattron(console_win, COLOR_PAIR(4) | A_BOLD); }
        wprintw(console_win, " [오류] 트랜잭션 롤백 및 연결 종료."); 
        if (has_colors()) {wattroff(console_win, COLOR_PAIR(4) | A_BOLD); }
    }
    wrefresh(console_win);

    return return_status;
}

// select
int inbound_select(wchar_t* input_buffer_w) {

    EXEC SQL WHENEVER SQLERROR DO sql_error("C 호출 중 Oracle 오류 발생 (조회)");
    EXEC SQL WHENEVER NOT FOUND GOTO no_data_found;

    int return_status = 0;

    VARCHAR inb_id_hv[16];
    VARCHAR prod_name_hv[101];
    VARCHAR dist_name_hv[51];
    VARCHAR cate_name_hv[51];
    VARCHAR inb_date_hv[11];
    int inb_qty_hv;
    float inb_cost_hv;

    char line[MAX_LINE_LENGTH];

    int max_rows, max_cols;
    int data_rows;
    int current_y = 5;

    EXEC SQL CONNECT :db_user IDENTIFIED BY :db_pass USING :db_connect_string;

    getmaxyx(output_win, max_rows, max_cols);
    data_rows = max_rows - 5;
    if (data_rows <= 0) data_rows = 1;

    EXEC SQL DECLARE inbound_cursor CURSOR FOR
        SELECT
            I.INB_ID, P.PROD_NAME, D.DIST_NAME, C.CATE_NAME,
            TO_CHAR(I.INB_DATE, 'YYYY-MM-DD'), I.INB_QTY, I.INB_COST
        FROM
            SYSTEM.INBOUND I,
            SYSTEM.PRODUCT P,
            SYSTEM.DISTRIBUTOR D,
            SYSTEM.CATEGORY C
        WHERE
            I.PROD_ID = P.PROD_ID AND I.DIST_ID = D.DIST_ID AND I.CATE_ID = C.CATE_ID
        ORDER BY I.INB_ID DESC;

    EXEC SQL OPEN inbound_cursor;

    werase(output_win);

    if (has_colors()) {wattron(output_win, COLOR_PAIR(7) | A_BOLD); }
        mvwprintw(output_win, 3, 2, "%-20s %-25s %-18s %-15s %-10s %8s %12s",
                  "입고ID", "상품명", "유통업체", "카테고리", "입고일자", "수량", "단가");
        mvwprintw(output_win, 4, 2, "-------------------- ------------------------- ------------------ --------------- ---------- -------- ------------");
    if (has_colors()) {wattroff(output_win, COLOR_PAIR(7) | A_BOLD); }

    for (int i = 0; i < data_rows; i++) {
        EXEC SQL FETCH inbound_cursor INTO
            :inb_id_hv, :prod_name_hv, :dist_name_hv, :cate_name_hv,
            :inb_date_hv, :inb_qty_hv, :inb_cost_hv;

        if (sqlca.sqlcode == 1403) break;

        inb_id_hv.arr[inb_id_hv.len] = '\0';
        prod_name_hv.arr[prod_name_hv.len] = '\0';
        dist_name_hv.arr[dist_name_hv.len] = '\0';
        cate_name_hv.arr[cate_name_hv.len] = '\0';
        inb_date_hv.arr[inb_date_hv.len] = '\0';

        mvwprintw(output_win, current_y++, 2, "%-20s %-25s %-18s %-15s %-10s %8d %12.2f",
                  inb_id_hv.arr, prod_name_hv.arr, dist_name_hv.arr, cate_name_hv.arr,
                  inb_date_hv.arr, inb_qty_hv, inb_cost_hv);
    }

    EXEC SQL CLOSE inbound_cursor;

    if (sqlca.sqlerrd[2] == 0) {
        wscrl(output_win, 1); wprintw(output_win, " [정보] 조회된 입고 내역이 없습니다.");
        return_status = 0;
    } else {
        wscrl(output_win, 1); wprintw(output_win, " [정보] 총 %d건의 입고 내역을 출력했습니다.", sqlca.sqlerrd[2]);
        return_status = 1;
    }

    goto cleanup;

query_error:
    wscrl(output_win, 1);
    wprintw(output_win, " [오류] 입고 내역 조회 중 DB 오류 발생.");
    wrefresh(output_win);
    return_status = 0;
    goto cleanup;

no_data_found:
    return_status = 1;
    goto cleanup;

cleanup:
    if (return_status == 1) {
        EXEC SQL COMMIT WORK RELEASE;
    } else {
        EXEC SQL ROLLBACK RELEASE;
    }

    wrefresh(output_win);
    return return_status;
}

int get_product_price(const char *barcode, int *quantity, char *product_name_out, double *price_out) {

    EXEC SQL WHENEVER SQLERROR GOTO query_error;
    EXEC SQL WHENEVER NOT FOUND GOTO not_found;

    int requested_qty = *quantity;
    int return_status = 0;

    int current_cart_qty = get_current_cart_quantity(barcode);

    int final_total_qty = current_cart_qty + requested_qty;

    EXEC SQL CONNECT :db_user IDENTIFIED BY :db_pass USING :db_connect_string;

    if (strlen(barcode) > 20 || requested_qty <= 0) {
        return_status = 0;
        goto cleanup;
    }

    size_t input_len = strlen(barcode);
    strcpy((char*)barcode_hv.arr, barcode);
    barcode_hv.arr[input_len] = '\0';
    barcode_hv.len = (unsigned short)input_len;

    EXEC SQL SELECT P.PROD_NAME, P.SELL_PRICE, I.CURRENT_QTY
             INTO :prod_name_hv, :sell_price_hv, :current_qty_hv
             FROM SYSTEM.PRODUCT P, SYSTEM.INVENTORY I
             WHERE RTRIM(P.BARCODE) = :barcode_hv
               AND P.PROD_ID = I.PROD_ID;

    if (final_total_qty > current_qty_hv) {
        return_status = -1;
        goto cleanup;
    }

    strncpy(product_name_out, (char*)prod_name_hv.arr, prod_name_hv.len);
    product_name_out[prod_name_hv.len] = '\0';
    *price_out = (double)sell_price_hv;

    return_status = 1;
    goto cleanup;

query_error:
    return_status = 0;
    goto cleanup;

not_found:
    return_status = 0;
    goto cleanup;

cleanup:

    if (return_status == 1) {
        EXEC SQL COMMIT WORK RELEASE;
    } else {
        EXEC SQL ROLLBACK RELEASE;
    }

    return return_status;
}


// 인자로 total_amount, paymeny_type 를 전달받아서
// 시퀀스가 적용된 SALE_NUM에 insert into sale values(SALE_NUM, DATE=SYSDATE, TOTAL_AMOUNT=total_amount, PAYMENT_TYPE=paymeny_type, EMP_ID=1) 을 처리하는 함수
// 성공적으로 넣으면 SALE_NUM을 반환하고 실패하면 -1을 반환한다.
char* insert_sale_record(double total_amount, const char *payment_type) {

    EXEC SQL WHENEVER SQLERROR GOTO query_error;
    EXEC SQL WHENEVER NOT FOUND GOTO query_error;

    long next_sale_num;
    static char result_sale_num[16];

    VARCHAR payment_type_hv[11];
    strcpy((char*)payment_type_hv.arr, payment_type);
    payment_type_hv.len = strlen(payment_type);

    VARCHAR emp_id_hv[11];
    strcpy((char*)emp_id_hv.arr, "1");
    emp_id_hv.len = 1;

    VARCHAR sale_num_hv[16];

    EXEC SQL CONNECT :db_user IDENTIFIED BY :db_pass USING :db_connect_string;

    EXEC SQL SELECT SYSTEM.SALE_NUM_SEQ.NEXTVAL INTO :next_sale_num FROM DUAL;

    sprintf((char*)sale_num_hv.arr, "%015ld", next_sale_num);
    sale_num_hv.len = strlen((char*)sale_num_hv.arr);

    strcpy(result_sale_num, (char*)sale_num_hv.arr);


    EXEC SQL INSERT INTO SYSTEM.SALE (SALE_NUM, SALE_DATE, TOTAL_AMOUNT, PAYMENT_TYPE, EMP_ID)
    VALUES (:sale_num_hv, SYSDATE, :total_amount, :payment_type_hv, :emp_id_hv);

    EXEC SQL COMMIT WORK RELEASE;

    return result_sale_num;

query_error:
    EXEC SQL ROLLBACK RELEASE;
    strcpy(result_sale_num, "-1");
    return result_sale_num;
}

// SALE_NUM, barcode, quantity, price 전달
// 시퀀스 적용 SALE_DETAIL_ID, 바코드를 앞3자를 제외하고 뒷 4자리만 prod_id에 저장
// insert into sale_detail values(SALE_DETAIL_ID, SALE_NUM=SALE_NUM, PROD_ID=prod_id, SALE_QTY=quantity, UNIT_PRICE=price, SUB_TOTAL=quantity*price)
// 삽입에 성공하면 1 실패하면 -1을 반환한다.
int insert_sale_detail_item(const char *sale_num, const char *barcode, int quantity, double price) {

    EXEC SQL WHENEVER SQLERROR GOTO query_error;
    EXEC SQL WHENEVER NOT FOUND GOTO query_error;

    long next_detail_id;

    VARCHAR detail_id_hv[16];
    VARCHAR sale_num_hv[16];
    VARCHAR prod_id_hv[5];
    double sub_total = (double)quantity * price;

    int remaining_qty = 0;

    EXEC SQL CONNECT :db_user IDENTIFIED BY :db_pass USING :db_connect_string;

    EXEC SQL SELECT SYSTEM.SALE_DETAIL_ID_SEQ.NEXTVAL INTO :next_detail_id FROM DUAL;

    sprintf((char*)detail_id_hv.arr, "%015ld", next_detail_id);
    detail_id_hv.len = strlen((char*)detail_id_hv.arr);

    strncpy((char*)prod_id_hv.arr, barcode + 3, 4);
    prod_id_hv.arr[4] = '\0';
    prod_id_hv.len = 4;

    strncpy((char*)sale_num_hv.arr, sale_num, 15);
    sale_num_hv.arr[15] = '\0';
    sale_num_hv.len = strlen((char*)sale_num_hv.arr);

    EXEC SQL INSERT INTO SYSTEM.SALE_DETAIL (SALE_DETAIL_ID, SALE_NUM, PROD_ID, SALE_QTY, UNIT_PRICE, SUB_TOTAL)
    VALUES (:detail_id_hv, :sale_num_hv, :prod_id_hv, :quantity, :price, :sub_total);

    EXEC SQL UPDATE SYSTEM.INVENTORY
             SET CURRENT_QTY = CURRENT_QTY - :quantity
             WHERE PROD_ID = :prod_id_hv
             RETURNING CURRENT_QTY INTO :remaining_qty;

    if (remaining_qty == 0) {
        EXEC SQL DELETE FROM SYSTEM.INVENTORY
                 WHERE PROD_ID = :prod_id_hv;

        wscrl(console_win, 1);
        if (has_colors()) {wattron(console_win, COLOR_PAIR(3) | A_BOLD); }
        mvwaddwstr(console_win, CONSOLE_HEIGHT - 2, 1, L" [로그] [상품 판매] 상품 재고가 0 이 되어 재고가 삭제되었습니다.");
        if (has_colors()) {wattroff(console_win, COLOR_PAIR(3) | A_BOLD); }
        wnoutrefresh(console_win);
    }

    EXEC SQL COMMIT WORK RELEASE;

    return 1;

query_error:
    EXEC SQL ROLLBACK RELEASE;
    return -1;
}